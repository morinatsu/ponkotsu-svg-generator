### Julesへの指示書 (v0.5.1 - Undo/Redo機構の修正)

### **プロジェクト名:**

ぽんこつSVGジェネレーター (v0.5.1 - Undo/Redo機構の修正)

### **プロジェクト概要:**

現在のUndo/Redo機構のロジックを修正し、**キャンバスの図形 (`shapes` 配列) に変更を加えるアクションのみ**を履歴として記録するようにします。ツールの選択や、図形の選択といったUI上の一時的な状態変更は履歴から除外し、Undo/Redoがユーザーの意図通りに動作するようにします。

-----

### **実装ステップの提案:**

Jules、以下のステップで `historyReducer.ts` を修正してください。

#### 1\. 履歴管理の対象を `shapes` 配列に絞り込む

`AppState` オブジェクト全体を履歴に保存するのではなく、**図形の状態 (`ShapeData[]`) のみ**を`past`と`future`に保存するように変更します。これにより、UIの状態が履歴に影響を与えることを防ぎます。

**`src/state/historyReducer.ts` の `HistoryState` 型定義を修正:**

```typescript:src/state/historyreducer.ts
import { type ShapeData, type Action, type AppState, reducer as originalReducer, initialState as originalInitialState } from './reducer';
import isEqual from 'lodash/isEqual';

// 変更前
// export interface HistoryState {
//     past: AppState[];
//     present: AppState;
//     future: AppState[];
// }

// 変更後
export interface HistoryState {
    past: ShapeData[][];       // 過去の図形リストの配列
    present: AppState;         // UIの状態も含む現在のフル状態
    future: ShapeData[][];      // 未来の図形リストの配列
}
```

#### 2\. アクションの種類に基づいた履歴記録ロジックへの変更

`isEqual`を使った汎用的な比較を廃止し、特定のアクションが実行された場合のみ履歴を更新する、より明確なロジックに書き換えます。

**`src/state/historyReducer.ts` の `undoable` Reducerを以下のように全面的に書き換えてください:**

```typescript:src/state/historyreducer.ts
// ... (import文とHistoryStateの定義は上記を参照)

// 履歴に記録するアクションのリストを定義
const recordableActions = new Set<string>([
    'END_DRAWING',
    'DELETE_SELECTED_SHAPE',
    'CLEAR_CANVAS',
]);

// Higher-order reducer to add undo/redo functionality
export const undoable = (reducer: typeof originalReducer) => {
    // 新しいInitial State
    const initialState: HistoryState = {
        past: [],
        present: originalInitialState,
        future: [],
    };

    return (state: HistoryState = initialState, action: HistoryAction): HistoryState => {
        const { past, present, future } = state;

        switch (action.type) {
            case 'UNDO': {
                if (past.length === 0) {
                    return state;
                }
                const previousShapes = past[past.length - 1];
                const newPast = past.slice(0, past.length - 1);
                return {
                    past: newPast,
                    present: { ...present, shapes: previousShapes, selectedShapeId: null }, // Undo時は選択を解除
                    future: [present.shapes, ...future],
                };
            }
            case 'REDO': {
                if (future.length === 0) {
                    return state;
                }
                const nextShapes = future[0];
                const newFuture = future.slice(1);
                return {
                    past: [...past, present.shapes],
                    present: { ...present, shapes: nextShapes, selectedShapeId: null }, // Redo時も選択を解除
                    future: newFuture,
                };
            }
            default: {
                // まず、元々のReducerで新しい状態を計算する
                const newPresent = reducer(present, action as Action);

                // もし、実行されたアクションが記録対象のアクションで、
                // かつ、shapes配列が実際に変更されていた場合のみ履歴を更新する
                if (
                    recordableActions.has((action as Action).type) &&
                    !isEqual(present.shapes, newPresent.shapes)
                ) {
                    // futureをクリアして、新しい履歴を追加
                    return {
                        past: [...past, present.shapes],
                        present: newPresent,
                        future: [],
                    };
                }

                // 記録対象外のアクション（SELECT_TOOLなど）の場合は、
                // 履歴を変更せず、presentの状態だけを更新する
                return { ...state, present: newPresent };
            }
        }
    };
};
```

この修正によって、`SELECT_TOOL`のようなアクションは履歴に記録されなくなり、`END_DRAWING`のようなキャンバス内容を永続的に変更するアクションのみがUndo/Redoの対象となります。これにより、デバッグで確認された問題が解消され、より安定した動作になります。