# ぽんこつSVGジェネレーター (v0.9 - 図形の拡大縮小機能)

### **プロジェクト概要:**

v0.8で実装された「回転」機能に続き、**「図形の拡大縮小（リサイズ）」**機能を実装します。
選択された図形の四隅に「リサイズハンドル」を表示し、ドラッグ操作によってサイズを変更できるようにします。

### **前提条件:**

* **回転との共存:** v0.8ですでに図形が回転できる状態になっています。回転した図形に対しても、正しく（ローカル座標系に基づいて）拡大縮小が行える必要があります。
* **アーキテクチャ:** イベント処理は `useInteractionManager` に、状態更新ロジックは `resizingReducer` に分離して実装します。

---

### **機能要件:**

#### 1. UI/UX仕様
* **ハンドルの表示:**
    * 図形が選択されている時、バウンディングボックスの四隅（NW, NE, SE, SW）に回転操作用の小さな円盤が表示されます。その円盤の内側が空いており、そこが拡大縮小用のハンドルになります。
    * このハンドルは、図形が回転していても図形と一緒に回転して表示されます。
* **カーソル:**
    * ハンドルにマウスを乗せた際、適切なリサイズカーソル（`nwse-resize` など）を表示します。※回転時はカーソルの向きが直感的でなくなる場合がありますが、今回はブラウザ標準のカーソルで妥協します。
* **操作:**
    * ハンドルをドラッグすると、**対角の点を固定点（アンカー）**として拡大縮小されます。
    * **Shiftキー:** Shiftキーを押しながらドラッグした場合、**アスペクト比（縦横比）を維持**してリサイズします。

#### 2. 対象図形ごとの挙動
* **Rectangle (長方形):** `width`, `height` を変更。座標 `x, y` も補正が必要。
* **Ellipse (楕円):** `rx`, `ry` を変更。中心 `cx, cy` も補正が必要。
* **Line (線):** 始点・終点の座標を変更（実質的には端点の移動）。
* **Text (テキスト):** サポートしません。

---

### **実装ステップ:**

Jules、以下の手順で実装を進めてください。

#### 1. 型定義とStateの更新 (`src/types.ts`, `src/state/reducer.ts`)

* **`AppState` に `resizingState` を追加:**
    ```typescript
    resizingState: {
      shapeId: string;
      handle: 'nw' | 'ne' | 'sw' | 'se'; // 操作中のハンドル位置
      startX: number; // ドラッグ開始時のマウスX
      startY: number; // ドラッグ開始時のマウスY
      initialShape: ShapeData; // 開始時の図形情報のスナップショット
    } | null;
    ```
* **`Action` 型の追加:**
    * `START_RESIZING`
    * `RESIZE_SHAPE`
    * `STOP_RESIZING`

#### 2. Reducerの実装 (`src/state/reducers/resizingReducer.ts`)

新規ファイルを作成し、リサイズロジックを記述します。ここが最も計算が複雑になる部分です。

* **回転した図形のリサイズ計算ロジック（重要）:**
    単純にマウスの移動量（dx, dy）を width/height に足すだけでは、図形が回転している場合に歪んでしまいます。以下の手順で計算する必要があります。

    1.  **マウス座標のローカル化:** 現在のマウス座標を、図形の中心を原点とし、回転角度分だけ逆回転させた「ローカル座標系」に変換します。
    2.  **新しい境界の計算:** ローカル座標系におけるマウス位置に基づいて、新しい `top`, `left`, `width`, `height` を計算します。
    3.  **座標の書き戻し:** 計算された新しい中心位置などを、再びグローバル座標系（回転させた状態）に戻して `x, y` (または `cx, cy`) を更新します。

#### 3. ジオメトリ・ユーティリティの拡張 (`src/utils/geometry.ts`)

* `getResizeHandleAt(pos, shape)`:
    * 前回の `getRotationHandleAt` と似ていますが、今回はハンドルそのもの（四隅の点）との当たり判定を行います。
    * 回転領域（Proximity UI）よりも内側、つまりハンドルの矩形内部でのクリックを優先して検出するように判定順序を調整する必要があります。

#### 4. インタラクションの統合 (`src/hooks/useInteractionManager.ts`)

* `handleMouseDown`:
    * クリック位置が「リサイズハンドル」上にあるかを判定します。
    * ハンドル上であれば `START_RESIZING` を発行します。
    * **優先順位:** リサイズハンドル > 回転領域 > ドラッグ（図形本体） > 描画（背景） の順で判定してください。
* `handleMouseMove`:
    * `mode === 'resizing'` の場合、`RESIZE_SHAPE` を発行します。
    * Shiftキーの状態もPayloadに含めてください。

#### 5. レンダリングの更新 (`src/components/Shape.tsx`)

* ハンドル自体は拡大縮小の影響を受けないよう（常に一定の大きさに見えるよう）、`vector-effect="non-scaling-stroke"` 等を工夫するか、あるいは単に `transform` の影響下にあるため、小さくなりすぎないよう注意が必要です。
* **SVG構造の提案:**
    ```tsx
    <g transform={`rotate(${rotation} ${cx} ${cy})`} ...>
      {/* 図形本体 */}
      <rect ... />
      
      {/* 選択時のみ表示するハンドル */}
      {isSelected && (
        <g>
           <rect x={localNw.x} y={localNw.y} width={8} height={8} fill="white" stroke="black" />
           {/* ... 他のハンドル */}
        </g>
      )}
    </g>
    ```

---

### **技術的な補足 (Julesへのメモ):**

回転した矩形のリサイズは数学的にややこしいですが、**「対角の固定点（Anchor）」**を見つけるのが鍵です。

例えば、**北西 (nw)** ハンドルを操作している時、固定点は **南東 (se)** です。
1.  固定点（se）の座標を取得します。
2.  現在のマウス位置を取得します。
3.  この2点間の距離と角度から、新しい矩形の中心とサイズを導出します。

ただし、`line`（線）の場合はシンプルに「始点」または「終点」の座標をマウス位置で上書きするだけで済みます。まずは `line` 以外の2次元図形（Rect, Ellipse）のロジックを共通化することを目指してください。
